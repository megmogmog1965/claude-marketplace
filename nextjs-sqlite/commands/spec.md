---
description: 実装計画書を作成する
allowed-tools: Bash, Read, Write, Edit, Grep, Glob
---

# 実装計画書作成コマンド

**$ARGUMENTS** で指定された要件定義を実現する詳細な実装計画書を作成します。具体的な要件定義が指示されていない場合は、実装計画をしたい要件をユーザーに聞いてください。

## 1. 仕様書ドキュメント構造

ファイル `docs/spec/{yyyyMMddHHmmss}-{title}.md` を以下の形式で作成してください：

```markdown
# {title}

## 概要

{実装アプローチの簡潔な要約}

## タスク

各タスクは機能的に独立して実装が完了でき、動作検証ができるようにすること。

### タスク1: マイグレーション - {タスク名}

**実装**:
1. [ ] Prismaスキーマの修正: `prisma/schema.prisma` を編集
   - モデル、フィールド、リレーション、インデックスの追加/変更
   - 例: `Post` モデルを追加し、`User` への `authorId` リレーションを設定
2. [ ] マイグレーション実行: `update-prisma-schema` skill を使用
   - `prisma/migrations/` にマイグレーションファイルを自動生成
   - データベースにマイグレーションを適用
   - Prisma Client を再生成

**品質チェック**:
1. [ ] スキーマ変更が正常に適用された
2. [ ] Prisma Client が再生成された
3. [ ] マイグレーションエラーがない
4. [ ] `build` subagent でビルドエラーがないことを確認

---

### タスク2: バックエンド - {タスク名}

**実装**:
1. [ ] APIルートの作成: `app/api/{resource}/route.ts`
   - HTTPメソッド: GET, POST, PUT, DELETE
   - Zod によるリクエスト検証
   - エラーハンドリング
2. [ ] ビジネスロジックの実装: `lib/{domain}.ts`
   - Prisma によるデータベースクエリ
   - データ変換
   - エラーハンドリング
3. [ ] 型定義の追加: `types/{domain}.ts`
   - リクエスト/レスポンス型
   - ドメイン型

**テスト** (実装後に記述):
1. [ ] ユニットテスト: `lib/{domain}.test.ts`
   - ビジネスロジックのテスト
   - データベースおよび外部リソース呼び出しのモック

**品質チェック**:
1. [ ] `test` subagent でテスト実行、エラーがあれば修正
2. [ ] `lint` subagent で静的解析実行、エラーがあれば修正
3. [ ] `build` subagent でビルド実行、エラーがあれば修正

---

### タスク3: フロントエンド - {タスク名}

**実装**:
1. [ ] ページの作成: `app/{route}/page.tsx`
   - Server Component で初期データ取得
   - Shadcn UI コンポーネントを使用
   - 既存の類似画面のパターンに従う
2. [ ] コンポーネントの作成: `components/{feature}/{Component}.tsx`
   - Client Component でインタラクティブな部分を実装
   - 既存コンポーネントを可能な限り再利用
   - TypeScript 型定義を追加

**テスト** (実装後に記述):
1. [ ] ユニットテスト: `components/{feature}/{Component}.test.tsx`
   - ビジネスロジックのテスト
   - fetch 等、外部リソース呼び出しのモック

**品質チェック**:
1. [ ] `lint` subagent で静的解析実行、エラーがあれば修正
2. [ ] `build` subagent でビルド実行、エラーがあれば修正
3. [ ] `run_dev` skill を使用してUIを手動検証

---
```

## 2. タスク種別

以下のカテゴリーでタスクを分類してください：

- **マイグレーション**: Prismaスキーマ変更、データベースマイグレーション
- **バックエンド**: APIルート、ビジネスロジック、データアクセス層
- **フロントエンド**: Next.js App Router による、UIコンポーネント、ページ、クライアントサイドロジック

## 3. 作業項目の分類

各タスク内の作業項目を以下で分類してください：

- **実装**: コードの作成、変更、削除
- **テスト**: ユニットテスト、統合テスト（実装後に記述）
- **品質チェック**: Linting、型チェック、ビルド検証

## 4. 既存実装の分析プロセス

以下の順序で既存実装を分析してください：

#### 4.1 データベーススキーマ確認

- `prisma/schema.prisma` で既存モデルを確認
- 必要なテーブル、フィールド、リレーション、インデックスの存在確認
- マイグレーション要否の判断

#### 4.2 バックエンド実装確認

- `app/api/` 配下のAPIルートを検索
- `lib/` 配下のビジネスロジックを検索
- 極力、既存実装を流用・変更する方針で分析する

#### 4.3 フロントエンド実装確認

- `app/` 配下のページを検索
- `components/` 配下のコンポーネントを検索
- **重要**: 類似する既存画面を見つけ、そのパターンに厳密に従う
- 極力、既存実装を流用・変更する方針で分析する

## 5. 本プロジェクト固有の考慮事項

[本プロジェクトの技術スタック](docs/architecture.md) を考慮してください。

## 6. テスト記述順序

**重要**: テストは常に実装完了後に記述すること。

**順序**: 実装 → テスト（逆ではない）

**理由**:
- テスト駆動開発（Test-Driven Development）は採用しません！
- よくある問題: 「正しいコードを実装し終わったが、AI がテストに合わせてコードを『修正』し、誤ったコードに戻ってしまう」
- 実装優先により、テストが正しい動作を検証することを保証

## 7. UI実装のベストプラクティス

**必ず最初に類似する既存画面を検索**:

```bash
# 類似ページを検索
find app -name "page.tsx"

# 利用可能なコンポーネントを確認
ls components/ui/

# 特定パターンを検索
grep -r "特定パターン" app/
```

**既存パターンに厳密に従う**:
- レイアウト構造を一致させる
- 同じスペーシングを使用 (p-4, gap-6, など)
- 同じ Shadcn UI コンポーネントを使用
- 確立されたカラー/タイポグラフィトークンに従う
- 参照: [UI Design Rules](../ui-design-rule.md)
